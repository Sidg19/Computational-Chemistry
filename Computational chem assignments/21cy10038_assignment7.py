# -*- coding: utf-8 -*-
"""21CY10038_assignment7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z14_jqSP15cHenkroFFSsas7OZMKK_Ec
"""

import numpy as np
import matplotlib.pyplot as plt
import math
import pandas as pd

from google.colab import files
uploaded = files.upload()

filename = list(uploaded.keys())[0]
df = pd.read_csv(filename, delim_whitespace=True, skiprows=2, names = ['x(A)','y(A)', 'z(A)'])
# df.rename(columns={'y': 'z', 'x': 'y', '#' : 'x'}, inplace=True)
df.head()

data = df.to_numpy()  #array for original data

e = 1                       #Epsilon
si = 3.4                    #Sigma
m = 40*1.66*10**(-24)       #Mass of each argon atom in grams
n = 26                      #Unit cell length in Ang
dt = 20*10**(-12)           #seconds

def pbc(x,y,z, n):      #PBC cell length = n Ang
  for i in range(len(x)):
    if x[i] > n/2:
      x[i] = x[i] - n


    elif x[i] < -n/2:
      x[i] = x[i] + n


    if y[i] > n/2:
      y[i] = y[i] - n


    elif y[i] < -n/2:
      y[i] = y[i] + n

    if z[i] > n/2:
      z[i] = z[i] - n

    elif z[i] < -n/2:
      z[i] = z[i] + n

  return x,y,z

#Distance travelled by each particle
def dist(x1,y1, z1, x2, y2, z2):
  r = np.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)
  return r

#Energy calculation
def LJ(r):
  V = 4*e*((si/r)**12 - (si/r)**6)
  return V

#Force calculation
def force(r):
  F = -4*e*(12*(si**12/r**13) - 6*(si**6/r**7))
  return F

#Verlet Algorithm
def verlet(r_p, r_c, dt, f):
  r = -r_p + 2*r_c + (dt**2)*f
  return r

#Taylor series for first step
def taylor(r_c, dt, f):
  r = r_c + dt**2/2*f
  return r

#Making dummy arrays to store the previous and current coordinates

R_P = np.zeros(shape=(365, 3))
R_C = np.zeros(shape=(365, 3))

#Individual columns

X = df['x(A)']
Y = df['y(A)']
Z = df['z(A)']

for i in range(10):    #Number of iterations

  F_A = np.zeros(shape=(365, 3))  #Force array with Fx Fy and Fz components felt by all particles

  for j in range(len(data)):
    for k in range(j+1, len(data)):

        Lx = X[j] - X[k]
        Ly = Y[j] - Y[k]
        Lz = Z[j] - Z[k]

        #Minimum image convention

        if Lx > n/2:
          Lx = Lx - n
        elif Lx < -n/2:
          Lx = Lx + n

        if Ly > n/2:
          Ly = Ly - n
        elif Ly < -n/2:
          Ly = Ly + n

        if Lz > n/2:
          Lz = Lz - n
        elif Lz < -n/2:
          Lz = Lz + n

        d = math.sqrt(Lx**2 + Ly**2 + Lz**2)

        #Cut off radius
        if d <= 10 and d>0:

          F = force(d)*10**(-7)

          # Taking force components for each particle and adding them together to find the accerleration in each direction
          F_A[j,0] += F*Lx/d
          F_A[j,1] += F*Ly/d
          F_A[j,2] += F*Lz/d

          #This is for the reverse force acting on 2 when we calculate force acting on 1 due to 2.
          F_A[k,0] -= F*Lx/d
          F_A[k,1] -= F*Ly/d
          F_A[k,2] -= F*Lz/d

        else:
          continue

  #Applying the taylor expansion and verlet algorithm now that we have the force components for each particle.

  if i == 0:
    for j in range(len(data)):
      R_C[j,0] = taylor(X[j], dt, F_A[j,0]/m)
      R_C[j,1] = taylor(Y[j], dt, F_A[j,1]/m)
      R_C[j,2] = taylor(Z[j], dt, F_A[j,2]/m)

      R_P[j,0] = X[j]
      R_P[j,1] = Y[j]
      R_P[j,2] = Z[j]

    pbc(R_C[:,0], R_C[:,1], R_C[:,2], 26)

  else:
    for j in range(len(data)):
      X[j] = verlet(R_P[j,0], R_C[j,0], dt, F_A[j,0]/m)
      Y[j] = verlet(R_P[j,1], R_C[j,1], dt, F_A[j,1]/m)
      Z[j] = verlet(R_P[j,2], R_C[j,2], dt, F_A[j,2]/m)

    pbc(R_C[:,0], R_C[:,1], R_C[:,2], 26)

    for k in range(len(data)):
      R_P[k,0] = R_C[k, 0]
      R_P[k,1] = R_C[k, 1]
      R_P[k,2] = R_C[k, 2]

    for l in range(len(data)):
      R_C[l,0] = X[l]
      R_C[l,1] = Y[l]
      R_C[l,2] = Z[l]

  if i == 4 or i == 9:
    print(f"Coordinates of {i+1}th iteration are:")
    print("\n")
    for j in range(len(data)):
      print(X[j], Y[j], Z[j])
    print("\n")

